#include "mem_swap.h"
#include "mapper.h"
#include "file_ops.h"
#include <linux/swapfile.h>
#include <linux/preempt.h>
#include <linux/spinlock.h>
#include <linux/spinlock_types.h>

extern void end_swap_bio_read(struct bio *bio, int err);
extern void end_swap_bio_write(struct bio *bio, int err);
extern struct bio *get_swap_bio(gfp_t gfp_flags, struct page *page, bio_end_io_t end_io);
#define SHM_DUMP
#define PROACTIVE_SWAP

/*OFFSET_1 and OFFSET_2 are used to store the swap-in meta data*/
#define OFFSET_1 1048576 //4G from the start of the shm
#define OFFSET_2 1310720 //5G from the start of the shm

#define DUMP_PERCENT 0.7

extern void __iomem * Nahanni_mem;
extern spinlock_t swap_lock;
static struct swap_info_struct *gsis;
static unsigned long pages_to_dump, pages_dumped;


static DECLARE_WAIT_QUEUE_HEAD(dump_thread_wait);
static DECLARE_WAIT_QUEUE_HEAD(swap_thread_wait);
static DECLARE_WAIT_QUEUE_HEAD(IO_thread_wait);


static int init = 0;
spinlock_t init_lock;

struct dump_args *dump_args;

unsigned long memswap_size_total = (1<<20); /*# of pages*/
unsigned long memswap_size = (1<<17); /*# of pages*/

struct task_struct *mempipe_dump_shm_thread;

int memswap_init(struct swap_info_struct *sis){
	/*Offset of the first free shm chunk, in terms of pages. This meta data is the first "long of the whole shm area*/
	unsigned long offset;
	char *start;
	int ret = 0;

	if(Nahanni_mem == NULL){
		printk(KERN_ERR "Nahanni_mem = NULL\n");
		return -1;
	}
	
	sis->mapper = init_mapper(8); /*For now, a shared memory swap partition consists of at most 8 sections*/

	if(sis->mapper == NULL){
		printk(KERN_ERR "sis->mapper initialization fails\n");
		return -1;
	}

	offset = *(unsigned long *)Nahanni_mem;
	
	if(offset == 0){
		offset = 1;
	}

	insert_mapper(sis->mapper, offset);

	printk("memswap_init, offset = %ld\n", offset);

	start = (char *)Nahanni_mem + offset*PAGE_SIZE;
	memset((char *)start, '0', memswap_size*PAGE_SIZE);

	offset += memswap_size_total;
	*(unsigned long *)Nahanni_mem = offset;
	
	sis->shm = start;
	sis->shm_start = sis->shm_end = 0;
	sis->disk_start = sis->disk_end = 0; 
	sis->mask = 1;
	sis->is_dump = 0;
	sis->swap_IO_finish = 1;
	sis->dump_thread_should_run = 0;

	gsis = sis;
	
	pages_to_dump = pages_dumped = 0;

	dump_args = (struct dump_args *)kmalloc(sizeof(struct dump_args), GFP_KERNEL);	
	if(dump_args) {
		dump_args->sis = sis;
	}
	mempipe_dump_shm_thread = kthread_run(mempipe_dump_shm, dump_args, "mempipe_dump");
	printk("before init return, mapper = %p\n", sis->mapper);
	return ret;
}

struct swapin_mdata* get_swapin_mdata(unsigned long offset)
{
	char *exist = (char *)gsis->shm + OFFSET_1*PAGE_SIZE + offset;
	if(*exist == '0') {
		return NULL;
	}else{
		struct swapin_mdata *mdata = (struct swapin_mdata *)((char *)gsis->shm + OFFSET_2*PAGE_SIZE + offset*sizeof(struct swapin_mdata));
		return mdata;
	}

}

int shm_almost_full(void){
	return ((gsis->disk_end - gsis->disk_start) >= memswap_size*DUMP_PERCENT);
}


void end_dump_page(struct bio *bio, int err)
{
	end_swap_bio_write(bio, err);
        pages_dumped++;

        if(pages_dumped == pages_to_dump){
		printk("~~~~~~~~~~~~~~finish dumping~~~~~~~~~~~~~~~~\n");
		gsis->disk_start += pages_dumped + 1;
		gsis->shm_start = gsis->disk_start;
	        pages_dumped = pages_to_dump = 0;
		gsis->swap_IO_finish = 1;
                wake_up_all(&IO_thread_wait);
        }
}


int mempipe_dump_shm(void *args)
{
	struct dump_args *dump_args = (struct dump_args *)args;
	//struct swap_info_struct *sis = dump_args->sis;
	unsigned long offset, start, end;
	struct bio *bio;
	struct page *page;
	int ret = 0;
	char *kaddr;

	while(!kthread_should_stop()) {
		
		if(kthread_should_stop())
			break;
	
		wait_event_interruptible(dump_thread_wait, (gsis->dump_thread_should_run == 1));
	

		start = dump_args->start;
                end = dump_args->end;
                pages_to_dump = end - start + 1;

		gsis->swap_IO_finish = 0;

                for(offset = start; offset <= end; offset++) {
			page = alloc_pages(GFP_KERNEL, 0);
                        if(!page)
                                printk(KERN_CRIT "page allocation failed\n");

                        lock_page(page);

                        memcpy(page_address(page), (char *)Nahanni_mem + offset*PAGE_SIZE, PAGE_SIZE);

			bio = get_swap_bio(GFP_KERNEL, page, end_dump_page);
			if (bio == NULL) {
				unlock_page(page);
				ret = -ENOMEM;
				goto out;
			}
			unlock_page(page);
			count_vm_event(PSWPIN);
			submit_bio(READ, bio);
                }

		wait_event_interruptible(IO_thread_wait, (gsis->swap_IO_finish == 1));
                gsis->is_dump = 0;
                gsis->dump_thread_should_run = 0;
		wake_up_all(&swap_thread_wait);
	}
out:
	return ret;
}



int mempipe_swap_writepage(struct page *page, struct writeback_control *wbc,
void (*end_write_func)(struct bio *, int))
{
        struct bio *bio;
        int ret = 0, rw = WRITE;

        struct swap_info_struct *sis = page_swap_info(page);
	pgoff_t offset;
        swp_entry_t entry;
	char *mdata_exist;

	entry.val = page_private(page);
        offset = swp_offset(entry);
	
	if(current == mempipe_dump_shm_thread) {
                goto shmem;
        }

	if(gsis->disk_start == gsis->disk_end){
		wait_event_interruptible(swap_thread_wait, (gsis->is_dump == 0));
	}

        if (sis->flags & SWP_FILE) {
        	printk("Error: swap_writepage sis->flags indicates SWAP_FILE\n");
	}
	
#ifdef SHM_DUMP
	if(offset < sis->shm_start){
		printk("hahahahahahaha writepage: this swap slot is on the disk\n");
		set_page_writeback(page);
		bio = get_swap_bio(GFP_NOIO, page, end_write_func);
		if (bio == NULL) {
			set_page_dirty(page);
			unlock_page(page);
			ret = -ENOMEM;
			goto out;
		}
		if (wbc->sync_mode == WB_SYNC_ALL)
			rw |= REQ_SYNC;

		count_vm_event(PSWPOUT);
		set_page_writeback(page);
		unlock_page(page);
		submit_bio(rw, bio);
                goto out;
        }


        if(init == 0){
                spin_lock(&init_lock);
                if(init == 0){
                        printk("start memswap_init()\n");
                        ret = memswap_init(sis);
                        init = 1;
                }
                spin_unlock(&init_lock);
        }
        BUG_ON(sis->mapper == NULL);

	if(gsis->is_dump == 1){
		wait_event_interruptible(swap_thread_wait, (gsis->is_dump == 0));
	}else{
		if(shm_almost_full()){
			dump_args->start = sis->disk_start;
			dump_args->end = sis->disk_end;
			
			//preempt_disable();
			if(gsis->is_dump == 1){
				wait_event_interruptible(swap_thread_wait, (gsis->is_dump = 0));
			}else{
				gsis->dump_thread_should_run = 1;
				wake_up_interruptible(&dump_thread_wait);
				gsis->is_dump = 1;
				wait_event_interruptible(swap_thread_wait, (gsis->is_dump == 0));
			}
			//preempt_enable();
		}
	}
	
#endif

shmem:
	/*The swap slot is in shared memory*/
	count_vm_event(PSWPOUT);

	mdata_exist = (char *)sis->shm + OFFSET_1*PAGE_SIZE + offset*sizeof(char);
        *mdata_exist = '0';

#ifdef PROACTIVE_SWAP
        if(page->idx == 1) {
                pgd_t *pgd;
                pud_t *pud;
                pmd_t *pmd;

                struct swapin_mdata *mdata = (struct swapin_mdata*)kmalloc(sizeof(struct swapin_mdata), GFP_KERNEL);
                unsigned long address = page->rmap_addrs[0];
                struct vm_area_struct *vma = page->rmap_vmas[0];

                pgd = pgd_offset(vma->vm_mm, address);
                pud = pud_offset(pgd, address);
                pmd = pmd_offset(pud, address);

                mdata->vma = vma;
                mdata->pmd = pmd;
                mdata->address = address;


                *mdata_exist = '1';
                memcpy((char *)sis->shm + OFFSET_2*PAGE_SIZE + offset*sizeof(struct swapin_mdata), (char *)mdata, sizeof(struct swapin_mdata));

                kfree(mdata);
        }
#endif

	//unsigned long Nahanni_offset = get_offset(sis->mapper, offset);
	//unsigned long Nahanni_offset = offset + 1;
	memcpy((char *)sis->shm + offset*PAGE_SIZE, (char *)kmap(page), PAGE_SIZE);
	kunmap(page);
        //unlock_page(page);
        //end_page_writeback(page);
	if(offset > sis->shm_end) {
		sis->shm_end = offset;
		sis->disk_end = sis->shm_end;
	}

out:
	return ret;
}

int mempipe_swap_readpage(struct page *page)
{
	struct bio *bio;
	int ret = 0;
	struct swap_info_struct *sis = page_swap_info(page);
	//Added by Qi
	swp_entry_t entry;
	pgoff_t offset;
	//

	BUG_ON(sis->shm == NULL);


	entry.val = page_private(page);
        offset = swp_offset(entry);
	
	if(current == mempipe_dump_shm_thread) {
                goto read;
        }

	if(init == 1 && gsis->is_dump == 1){
		wait_event_interruptible(swap_thread_wait, (gsis->is_dump == 0));
	}
read:
	VM_BUG_ON_PAGE(!PageLocked(page), page);
	VM_BUG_ON_PAGE(PageUptodate(page), page);
	if (frontswap_load(page) == 0) {
		SetPageUptodate(page);
		unlock_page(page);
		goto out;
	}

	if (sis->flags & SWP_FILE) {
        	printk("Error: swap_readpage sis->flags indicates SWAP_FILE\n");
	}
	
#ifdef SHM_DUMP 
	if(offset < sis->shm_start) {
		printk("hahahahahahaha readpage: this swap slot is on the disk\n");
		bio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);
		if (bio == NULL) {
			unlock_page(page);
			ret = -ENOMEM;
			goto out;
		}
		count_vm_event(PSWPIN);
		submit_bio(READ, bio);
                goto out;
        }
#endif
	
	count_vm_event(PSWPIN);
	//offset = get_offset(sis->mapper, offset);
	//offset = offset + 1;
	memcpy((char *)kmap(page), (char *)sis->shm + offset*PAGE_SIZE, PAGE_SIZE);
	kunmap(page);
	SetPageUptodate(page);
	unlock_page(page);
	
out:
	return ret;
}
