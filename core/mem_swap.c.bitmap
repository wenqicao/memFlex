#include "mem_swap.h"
#include "mapper.h"
#include "bitmap.h"
#include <linux/swapfile.h>
#include <linux/preempt.h>
#include <linux/spinlock.h>
#include <linux/spinlock_types.h>

#define PROACTIVE_SWAP
#define TH 0.8
#define BITS_PER_BYTE 8 /*another definition in bitmap.h*/

/*OFFSET_1 and OFFSET_2 are used to store the swap-in meta data*/
#define OFFSET_1 1048576 //4G from the start of the shm
#define OFFSET_2 1310720 //5G from the start of the shm



extern void __iomem * Nahanni_mem;
extern spinlock_t swap_lock;
static struct swap_info_struct *gsis;



static int init = 0;
spinlock_t init_lock;

/*size is in terms of pages*/
unsigned long shm_total = (1<<20);/*size of the shm*/
unsigned long memswap_size = 0;/*size of the current shm swap area*/
unsigned long memswap_chunk = (1<<20); /*size of a shm chunk*/
unsigned long last_page;

struct task_struct *mempipe_dump_shm_thread;

int memswap_init(struct swap_info_struct *sis){
	/*Offset of the first free shm chunk, in terms of pages. This meta data is the first "long of the whole shm area*/
	unsigned long chunk_offset;
	char *p = (char *)Nahanni_mem;
	int ret = 0;
	unsigned long chunk_num, byte_num;

	if(Nahanni_mem == NULL){
		printk(KERN_ERR "Nahanni_mem = NULL\n");
		return -1;
	}
	
	/*For now, a shared memory swap partition consists of at most 8 sections*/
	sis->mapper = init_mapper(8);

	if(sis->mapper == NULL){
		printk(KERN_ERR "sis->mapper initialization fails\n");
		return -1;
	}

	chunk_num = shm_total/memswap_chunk; /*number of chunks/bits*/
	byte_num = (chunk_num + BITS_PER_BYTE - 1)/BITS_PER_BYTE;
	clear_all_bits(p, byte_num*BITS_PER_BYTE);

	chunk_offset = first_zero_bit(p, chunk_num);
	printk("init chunk_offset = %ld\n", chunk_offset);

	if(chunk_offset != -1){
		setbit(p, chunk_offset);
	}

	sis->shm = p + PAGE_SIZE;
	

	sis->shm_start = sis->shm_end = (unsigned long)(sis->shm + chunk_offset*memswap_chunk*PAGE_SIZE);
	sis->disk_start = sis->disk_end = (unsigned long)(sis->shm + chunk_offset*memswap_chunk*PAGE_SIZE);
	memswap_size += memswap_chunk;
	
	printk("sis->shm_start = %p\n", sis->shm_start);
	insert_mapper(sis->mapper, chunk_offset);

	memset((char *)sis->shm_start, '0', memswap_chunk*PAGE_SIZE);

	gsis = sis;

	printk("before init return, mapper = %p\n", sis->mapper);
	return ret;
}

struct swapin_mdata* get_swapin_mdata(unsigned long offset)
{
	char *exist = (char *)gsis->shm + OFFSET_1*PAGE_SIZE + offset;
	if(*exist == '0') {
		return NULL;
	}else{
		struct swapin_mdata *mdata = (struct swapin_mdata *)((char *)gsis->shm + OFFSET_2*PAGE_SIZE + offset*sizeof(struct swapin_mdata));
		return mdata;
	}

}

int shm_almost_full(void){
	return ((gsis->disk_end - gsis->disk_start) >= memswap_size*TH);
}


int mempipe_swap_writepage(struct page *page, struct writeback_control *wbc, void (*end_write_func)(struct bio *, int))
{
        int ret = 0;

        struct swap_info_struct *sis = page_swap_info(page);
	pgoff_t offset;
        swp_entry_t entry;
	char *mdata_exist, *start;

	entry.val = page_private(page);
        offset = swp_offset(entry);

	if(init == 0){
                spin_lock(&init_lock);
                if(init == 0){
                        printk("start memswap_init()\n");
                        ret = memswap_init(sis);
                        init = 1;
                }
                spin_unlock(&init_lock);
        }
	
        if (sis->flags & SWP_FILE) {
        	printk("Error: swap_writepage sis->flags indicates SWAP_FILE\n");
	}

	count_vm_event(PSWPOUT);

	mdata_exist = (char *)sis->shm + OFFSET_1*PAGE_SIZE + offset*sizeof(char);
        *mdata_exist = '0';

#ifdef PROACTIVE_SWAP
        if(page->idx == 1) {
                pgd_t *pgd;
                pud_t *pud;
                pmd_t *pmd;

                struct swapin_mdata *mdata = (struct swapin_mdata*)kmalloc(sizeof(struct swapin_mdata), GFP_KERNEL);
                unsigned long address = page->rmap_addrs[0];
                struct vm_area_struct *vma = page->rmap_vmas[0];

                pgd = pgd_offset(vma->vm_mm, address);
                pud = pud_offset(pgd, address);
                pmd = pmd_offset(pud, address);

                mdata->vma = vma;
                mdata->pmd = pmd;
                mdata->address = address;


                *mdata_exist = '1';
                memcpy((char *)sis->shm + OFFSET_2*PAGE_SIZE + offset*sizeof(struct swapin_mdata), (char *)mdata, sizeof(struct swapin_mdata));

                kfree(mdata);
        }
#endif
	//offset = get_offset(sis->mapper, offset);
	start = (char *)sis->shm + offset*PAGE_SIZE;
	memcpy(start, (char *)kmap(page), PAGE_SIZE);
	kunmap(page);
	
	if(offset > sis->shm_end) {
		sis->shm_end = offset;
		sis->disk_end = sis->shm_end;
	}

	return ret;
}

int mempipe_swap_readpage(struct page *page)
{
	int ret = 0;
	struct swap_info_struct *sis = page_swap_info(page);
	swp_entry_t entry;
	pgoff_t offset;

	BUG_ON(sis->shm == NULL);


	entry.val = page_private(page);
        offset = swp_offset(entry);
	
	VM_BUG_ON_PAGE(!PageLocked(page), page);
	VM_BUG_ON_PAGE(PageUptodate(page), page);
	if (frontswap_load(page) == 0) {
		SetPageUptodate(page);
		unlock_page(page);
		goto out;
	}

	if (sis->flags & SWP_FILE) {
        	printk("Error: swap_readpage sis->flags indicates SWAP_FILE\n");
	}
	
	
	count_vm_event(PSWPIN);
	
	//offset = get_offset(sis->mapper, offset);
	memcpy((char *)kmap(page), (char *)sis->shm + offset*PAGE_SIZE, PAGE_SIZE);
	kunmap(page);
	SetPageUptodate(page);
	unlock_page(page);
	
out:
	return ret;
}
